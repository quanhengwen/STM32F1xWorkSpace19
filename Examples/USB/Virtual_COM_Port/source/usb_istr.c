/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
* File Name          : usb_istr.c
* Author             : MCD Application Team
* Version            : V2.2.0
* Date               : 06/13/2008
* Description        : ISTR events interrupt service routines
********************************************************************************
* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
*******************************************************************************/


/******************************** 说明20160912**********************************
********************************************************************************
* 功能：直接处理USB中断
* 
* 
* 
* 
* 
*******************************************************************************/

/* Includes ------------------------------------------------------------------*/
#include "usb_lib.h"
#include "usb_prop.h"
#include "usb_pwr.h"
#include "usb_istr.h"

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
//volatile u16 wIstr;  					/* ISTR register last read value */	//中断值
volatile u8 bIntPackSOF = 0;  /* SOFs received between 2 consecutive packets */
//usb_istr_def	wIstr;

/* Extern variables ----------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/
/* function pointers to non-control endpoints service routines */
void (*pEpInt_IN[7])(void) =
  {
    EP1_IN_Callback,
    EP2_IN_Callback,
    EP3_IN_Callback,
    EP4_IN_Callback,
    EP5_IN_Callback,
    EP6_IN_Callback,
    EP7_IN_Callback,
  };

void (*pEpInt_OUT[7])(void) =
  {
    EP1_OUT_Callback,
    EP2_OUT_Callback,
    EP3_OUT_Callback,
    EP4_OUT_Callback,
    EP5_OUT_Callback,
    EP6_OUT_Callback,
    EP7_OUT_Callback,
  };


/*******************************************************************************
* Function Name  : USB_Istr.
* Description    : ISTR events interrupt service routine.
*	描述说明				:		中断事件处理-根据中断状态寄存器判断中断类型，转入相应的处理函数
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void USB_Istr(void)
{

  USB_REG.wIstr.istr	=	_GetISTR();	//wIstr = _GetISTR();			//获取中断标志，得到中断源
	//--------------------------USB复位请求 (USB reset request)
#if (IMR_MSK & ISTR_RESET)
  if (USB_REG.wIstr.istr & ISTR_RESET & wInterrupt_Mask)
  {
    _SetISTR((u16)CLR_RESET);		//清除USB复位请求 (USB reset request)
		pProperty->Reset();					//USB复位
#ifdef RESET_CALLBACK
    RESET_Callback();
#endif
  }
#endif
  //--------------------------PMA缓存溢出(Packet memory area over / underrun)
#if (IMR_MSK & ISTR_DOVR)
  if (USB_REG.wIstr.istr & ISTR_DOVR & wInterrupt_Mask)
  {
    _SetISTR((u16)CLR_DOVR);	//清除分组缓冲区溢出 (Packet memory area over / underrun)
#ifdef DOVR_CALLBACK
    DOVR_Callback();
#endif
  }
#endif
  //--------------------------传输出错：USB应用程序通常可以忽略这些错误，因为USB模块和主机在发生错误时都会启动重传机制。
	//													此位产生的中断可以用于应用程序的开发阶段，可以用来监测USB总线的传输质量，标识用户可能发生的错误(连接线松，环境干扰严重，USB线损坏等)。
#if (IMR_MSK & ISTR_ERR)			//出错 (Error)
  if (USB_REG.wIstr.istr & ISTR_ERR & wInterrupt_Mask)
  {
    _SetISTR((u16)CLR_ERR);		//清除出错 (Error)
#ifdef ERR_CALLBACK
    ERR_Callback();
#endif
  }
#endif
  //--------------------------唤醒请求 (Wakeup)
#if (IMR_MSK & ISTR_WKUP)
  if (USB_REG.wIstr.istr & ISTR_WKUP & wInterrupt_Mask)
  {
    _SetISTR((u16)CLR_WKUP);	//清除唤醒请求 (Wakeup)
    Resume(RESUME_EXTERNAL);
#ifdef WKUP_CALLBACK
    WKUP_Callback();
#endif
  }
#endif
  //--------------------------挂起模块请求 (Suspend mode request)
#if (IMR_MSK & ISTR_SUSP)
  if (USB_REG.wIstr.istr & ISTR_SUSP & wInterrupt_Mask)
  {
    /* check if SUSPEND is possible */
    if (fSuspendEnabled)
    {
      Suspend();
    }
    else
    {
      /* if not possible then resume after xx ms */
      Resume(RESUME_LATER);
    }
    /* clear of the ISTR bit must be done after setting of CNTR_FSUSP */
    _SetISTR((u16)CLR_SUSP);
#ifdef SUSP_CALLBACK
    SUSP_Callback();
#endif
  }
#endif
  //--------------------------//帧首(SOF)中断标志，中断服务程序可以通过检测SOF事件来完成与主机的1ms同
#if (IMR_MSK & ISTR_SOF)										
  if (USB_REG.wIstr.istr & ISTR_SOF & wInterrupt_Mask)		//读出的中断标志是SOF中断标志，且SOF中断使能了
  {
    _SetISTR((u16)CLR_SOF);									//清除SOF中断标志
    bIntPackSOF++;													//统计共接收到多少SOF

#ifdef SOF_CALLBACK
    SOF_Callback();													//当定义了SOF_CALLBACK，则调用SOF_Callback,像钩子函数一样，在发生SOF中断时做点什么
#endif
  }
#endif
  //--------------------------期望帧首标识位 (Expected start of frame)	如果连续发生3次ESOF中断，也就是连续3次未收到SOF分组，将产生SUSP中断。即使在挂起定时器未被锁定时发生SOF分组丢失，此位也会被置位。
#if (IMR_MSK & ISTR_ESOF)								
  if (USB_REG.wIstr.istr & ISTR_ESOF & wInterrupt_Mask)
  {
    _SetISTR((u16)CLR_ESOF);
    /* resume handling timing is made with ESOFs */
    Resume(RESUME_ESOF); /* request without change of the machine state */

#ifdef ESOF_CALLBACK
    ESOF_Callback();
#endif
  }
#endif
  //--------------------------正确的传输 (Correct transfer)：此位在端点正确完成一次数据传输后由硬件置位。应用程序可以通过DIR和EP_ID位来识别是哪个端点完成了正确的数据传输。
#if (IMR_MSK & ISTR_CTR)									
  if (USB_REG.wIstr.istr & ISTR_CTR & wInterrupt_Mask)
  {
    /* servicing of the endpoint correct transfer interrupt */
    /* clear of the CTR flag into the sub */
    CTR_LP();				//usb_int.c						//调用正确传输中断服务程序：控制端点及其它端点服务程序
#ifdef CTR_CALLBACK			//未启用
    CTR_Callback();
#endif
  }
#endif
} /* USB_Istr */

/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
